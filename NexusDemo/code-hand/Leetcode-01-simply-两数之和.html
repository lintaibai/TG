<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leetcode</title>
</head>

<body>
    <script>

    //2020-02  
    console.log('Leetcode-两数之和简易01');

    let nums = [2, 7, 11, 15],
        target = 13;

    function tosum(arr, target) {
        for (let i in arr) {
            for (let s in arr) {
                if (arr[i] + arr[s] == target) {
                    return [i, s];
                }
            }
        }
    }
    console.log(tosum([2, 7, 11, 15], target));


    // 2022
    console.log('Leetcode-两数之和简易01');
    /* 01Leetcode- 两数之和简易
    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target  的那 两个 整数，并返回它们的数组下标。
    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
    你可以按任意顺序返回答案。
    nums = [2,7,11,15], target = 9;

    示例 1：
    输入：nums = [2,7,11,15], target = 9
    输出：[0,1]
    解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
    示例 2：

    输入：nums = [3,2,4], target = 6
    输出：[1,2]
    示例 3：

    输入：nums = [3,3], target = 6
    输出：[0,1]
    */


    // 方式一 双层暴力解
    // var nums= [2,7,11,15];
    // var target = 9;
    // var twoSum = function (nums, target) {
    //     for (let i = 0; i < nums.length; i++) {
    //         for (let s = i + 1; s < nums.length; s++) {
    //             if (target==nums[i] + nums[s]) {
    //                 return[i,s];
    //             }
    //         }
    //     }
    // };
    // // twoSum([2,7,11,15],13); 
    // console.log(twoSum([2,7,11,15],13)); //2+11  [0,2]
    // console.log(twoSum([2,7,11,15],22)); //2+11  [1,3]




    // 方式2  --- 七颗  
    var nums = [2, 11, 7, 15],target = 13;
    var twoSum = function(nums, target) {
        var keys = {};
        for (var i = 0; i < nums.length; i++) {
            var diff = target - nums[i]; // 13-2 11
            console.log(diff,'diff'); // 11
            // 判断差值diff在键值对中是否存在 是则找到匹配数字 数组第二个数字为7，下标为1
            // keys[diff]=7,i=2 isNaN(6) true
            if (!isNaN(keys[diff])) { //
                // 返回减去的数字下标和差值数字的下标
                return [keys[diff], i];
            }
            // 未出现匹配值 将数字存入键值对中以备后续判断
            // 当前数字假设为第三个 nums[i]=7,keys[7]=1  i就是判断数字的下标  建立key值 方便下次使用
            // 若是7的差值不存在，当前数字7的下标就是1，将1记录为7的下标
            keys[nums[i]] = i;
        }
        console.log(keys,'keys');
    };
    console.log(twoSum([2,7,11,15],13)); //2+11  [0,2]




    </script>
</body>

</html>